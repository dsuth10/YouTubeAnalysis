{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Express.js Server and Project Structure",
        "description": "Initialize the Node.js project with Express.js server, configure middleware, and establish the basic project structure.",
        "details": "1. Initialize Node.js project with `npm init -y`\n2. Install core dependencies: express@4.18.2, cors@2.8.5, dotenv@16.3.1, axios@1.6.0\n3. Create server.js with basic Express configuration:\n```javascript\nrequire('dotenv').config();\nconst express = require('express');\nconst cors = require('cors');\nconst path = require('path');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(cors());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\n// Basic health check endpoint\napp.get('/api/health', (req, res) => {\n  res.status(200).json({ status: 'ok' });\n});\n\n// API routes will be added here\n\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n```\n4. Create folder structure:\n   - `/public` - for frontend files\n   - `/routes` - for API route handlers\n   - `/services` - for business logic\n   - `/utils` - for helper functions\n   - `/prompts` - for analysis templates\n5. Create .env file with placeholder variables\n6. Setup error handling middleware\n7. Configure package.json scripts for development and production",
        "testStrategy": "1. Verify server starts without errors\n2. Test health check endpoint returns 200 status\n3. Confirm static file serving works correctly\n4. Validate CORS configuration with cross-origin requests\n5. Test error handling middleware with invalid routes",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement YouTube API Integration",
        "description": "Integrate with YouTube Data API v3 to fetch video metadata and validate YouTube URLs.",
        "details": "1. Install required package: `npm install googleapis@126.0.1`\n2. Create YouTube service in `/services/youtube.js`:\n```javascript\nconst { google } = require('googleapis');\nconst youtube = google.youtube({\n  version: 'v3',\n  auth: process.env.YOUTUBE_API_KEY\n});\n\nasync function getVideoMetadata(videoId) {\n  try {\n    const response = await youtube.videos.list({\n      part: 'snippet,contentDetails,statistics',\n      id: videoId\n    });\n    \n    if (!response.data.items.length) {\n      throw new Error('Video not found');\n    }\n    \n    const video = response.data.items[0];\n    return {\n      id: video.id,\n      title: video.snippet.title,\n      channel: video.snippet.channelTitle,\n      publishedAt: video.snippet.publishedAt,\n      description: video.snippet.description,\n      thumbnail: video.snippet.thumbnails.high.url,\n      duration: video.contentDetails.duration,\n      viewCount: video.statistics.viewCount,\n      likeCount: video.statistics.likeCount\n    };\n  } catch (error) {\n    console.error('YouTube API error:', error);\n    throw error;\n  }\n}\n\nfunction extractVideoId(url) {\n  const patterns = [\n    /(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/|youtube\\.com\\/embed\\/|youtube\\.com\\/shorts\\/|youtube\\.com\\/live\\/)([^&\\?\\n]+)/\n  ];\n  \n  for (const pattern of patterns) {\n    const match = url.match(pattern);\n    if (match && match[1]) {\n      return match[1];\n    }\n  }\n  \n  throw new Error('Invalid YouTube URL format');\n}\n\nmodule.exports = {\n  getVideoMetadata,\n  extractVideoId\n};\n```\n3. Create API route for video metadata in `/routes/youtube.js`\n4. Implement URL validation with support for all required formats\n5. Add error handling for API rate limits and invalid videos\n6. Implement caching mechanism to reduce API calls for previously fetched videos\n7. Add YouTube API key validation on startup",
        "testStrategy": "1. Test URL extraction with all supported formats\n2. Verify metadata extraction with various video types\n3. Test error handling for invalid URLs and videos\n4. Validate rate limit handling\n5. Verify caching mechanism reduces API calls\n6. Test with videos that have different metadata availability",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Develop Basic Frontend Interface",
        "description": "Create the initial HTML, CSS, and JavaScript for the frontend interface with form submission and results display.",
        "details": "1. Create basic HTML structure in `/public/index.html`:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>YouTube Video Research App</title>\n  <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n  <header>\n    <h1>YouTube Video Research App</h1>\n  </header>\n  \n  <main>\n    <section id=\"input-section\">\n      <form id=\"analysis-form\">\n        <div class=\"form-group\">\n          <label for=\"youtube-url\">YouTube Video URL</label>\n          <input type=\"url\" id=\"youtube-url\" name=\"youtube-url\" required \n                 placeholder=\"https://www.youtube.com/watch?v=...\">\n        </div>\n        \n        <div class=\"form-group\">\n          <label for=\"ai-model\">AI Model</label>\n          <select id=\"ai-model\" name=\"ai-model\">\n            <option value=\"gpt-3.5-turbo\">GPT-3.5 Turbo (Recommended)</option>\n            <option value=\"gpt-4\">GPT-4 (Premium)</option>\n            <option value=\"claude-2\">Claude 2</option>\n          </select>\n        </div>\n        \n        <div class=\"form-group\">\n          <label for=\"prompt-template\">Analysis Template</label>\n          <select id=\"prompt-template\" name=\"prompt-template\">\n            <option value=\"general\">General Analysis</option>\n            <option value=\"tutorial\">Tutorial Analysis</option>\n            <option value=\"review\">Product Review Analysis</option>\n          </select>\n        </div>\n        \n        <div class=\"form-group\">\n          <label for=\"token-limit\">Analysis Depth</label>\n          <input type=\"range\" id=\"token-limit\" name=\"token-limit\" \n                 min=\"2000\" max=\"20000\" step=\"1000\" value=\"6000\">\n          <span id=\"token-display\">6,000 tokens</span>\n        </div>\n        \n        <button type=\"submit\" id=\"analyze-btn\">Analyze Video</button>\n      </form>\n    </section>\n    \n    <section id=\"results-section\" class=\"hidden\">\n      <div id=\"video-info\">\n        <!-- Video metadata will be displayed here -->\n      </div>\n      \n      <div id=\"analysis-results\">\n        <!-- Analysis results will be displayed here -->\n      </div>\n      \n      <div id=\"download-options\">\n        <button id=\"download-md\">Download Markdown</button>\n        <button id=\"download-transcript\">Download Transcript</button>\n      </div>\n    </section>\n    \n    <div id=\"status-container\">\n      <div id=\"status-message\"></div>\n      <div id=\"loading-indicator\" class=\"hidden\"></div>\n    </div>\n  </main>\n  \n  <script src=\"script.js\"></script>\n</body>\n</html>\n```\n\n2. Create modern CSS styles in `/public/styles.css` with responsive design\n3. Implement frontend JavaScript in `/public/script.js`:\n```javascript\ndocument.addEventListener('DOMContentLoaded', () => {\n  const analysisForm = document.getElementById('analysis-form');\n  const resultsSection = document.getElementById('results-section');\n  const statusMessage = document.getElementById('status-message');\n  const loadingIndicator = document.getElementById('loading-indicator');\n  const tokenLimit = document.getElementById('token-limit');\n  const tokenDisplay = document.getElementById('token-display');\n  \n  // Update token display when slider changes\n  tokenLimit.addEventListener('input', () => {\n    tokenDisplay.textContent = `${Number(tokenLimit.value).toLocaleString()} tokens`;\n  });\n  \n  // Handle form submission\n  analysisForm.addEventListener('submit', async (e) => {\n    e.preventDefault();\n    \n    const youtubeUrl = document.getElementById('youtube-url').value;\n    const aiModel = document.getElementById('ai-model').value;\n    const promptTemplate = document.getElementById('prompt-template').value;\n    const tokenLimitValue = tokenLimit.value;\n    \n    // Show loading state\n    showStatus('Analyzing video...', true);\n    resultsSection.classList.add('hidden');\n    \n    try {\n      // Call API to analyze video\n      const response = await fetch('/api/analyze', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          url: youtubeUrl,\n          model: aiModel,\n          promptTemplate: promptTemplate,\n          tokenLimit: tokenLimitValue\n        })\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Failed to analyze video');\n      }\n      \n      const data = await response.json();\n      displayResults(data);\n      showStatus('Analysis complete!', false);\n      resultsSection.classList.remove('hidden');\n      \n    } catch (error) {\n      showStatus(`Error: ${error.message}`, false, true);\n    }\n  });\n  \n  // Display analysis results\n  function displayResults(data) {\n    const videoInfo = document.getElementById('video-info');\n    const analysisResults = document.getElementById('analysis-results');\n    \n    // Display video metadata\n    videoInfo.innerHTML = `\n      <div class=\"video-header\">\n        <img src=\"${data.videoInfo.thumbnail}\" alt=\"${data.videoInfo.title}\">\n        <div class=\"video-details\">\n          <h2>${data.videoInfo.title}</h2>\n          <p>Channel: ${data.videoInfo.channel}</p>\n          <p>Published: ${new Date(data.videoInfo.publishedAt).toLocaleDateString()}</p>\n          <p>Views: ${Number(data.videoInfo.viewCount).toLocaleString()}</p>\n        </div>\n      </div>\n    `;\n    \n    // Display analysis\n    analysisResults.innerHTML = `<div class=\"markdown-content\">${markdownToHtml(data.analysis)}</div>`;\n    \n    // Setup download buttons\n    document.getElementById('download-md').onclick = () => downloadFile(data.analysis, `${sanitizeFilename(data.videoInfo.title)}-analysis.md`, 'text/markdown');\n    \n    if (data.transcript) {\n      document.getElementById('download-transcript').classList.remove('hidden');\n      document.getElementById('download-transcript').onclick = () => downloadFile(data.transcript, `${sanitizeFilename(data.videoInfo.title)}-transcript.txt`, 'text/plain');\n    } else {\n      document.getElementById('download-transcript').classList.add('hidden');\n    }\n  }\n  \n  // Helper functions\n  function showStatus(message, isLoading = false, isError = false) {\n    statusMessage.textContent = message;\n    statusMessage.className = isError ? 'error' : '';\n    loadingIndicator.classList.toggle('hidden', !isLoading);\n  }\n  \n  function sanitizeFilename(name) {\n    return name.replace(/[^a-z0-9]/gi, '_').toLowerCase();\n  }\n  \n  function downloadFile(content, filename, contentType) {\n    const blob = new Blob([content], { type: contentType });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n  \n  function markdownToHtml(markdown) {\n    // Simple markdown to HTML conversion\n    // In a real implementation, use a proper markdown parser\n    return markdown\n      .replace(/^### (.*$)/gim, '<h3>$1</h3>')\n      .replace(/^## (.*$)/gim, '<h2>$1</h2>')\n      .replace(/^# (.*$)/gim, '<h1>$1</h1>')\n      .replace(/\\*\\*(.*?)\\*\\*/gim, '<strong>$1</strong>')\n      .replace(/\\*(.*?)\\*/gim, '<em>$1</em>')\n      .replace(/\\n/gim, '<br>');\n  }\n});\n```\n4. Implement responsive design with mobile-first approach\n5. Add form validation for YouTube URL\n6. Create loading indicators and status messages\n7. Implement basic error handling and user feedback",
        "testStrategy": "1. Test form submission with valid and invalid URLs\n2. Verify responsive design on different screen sizes\n3. Test loading indicators and status messages\n4. Validate form validation for required fields\n5. Test UI rendering with different types of results\n6. Verify error messages are displayed correctly",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Transcript Extraction System",
        "description": "Create a robust transcript extraction system with multiple fallback methods to handle different YouTube video types.",
        "details": "1. Install required packages: `npm install youtube-transcript@1.2.1 youtube-captions-scraper@2.0.3`\n2. Create transcript service in `/services/transcript.js`:\n```javascript\nconst { YoutubeTranscript } = require('youtube-transcript');\nconst { getSubtitles } = require('youtube-captions-scraper');\nconst { getVideoMetadata } = require('./youtube');\n\nasync function getTranscript(videoId) {\n  // Try multiple methods in sequence\n  try {\n    // Method 1: youtube-transcript package\n    return await getTranscriptMethod1(videoId);\n  } catch (error1) {\n    console.log('Method 1 failed, trying method 2...');\n    try {\n      // Method 2: youtube-captions-scraper\n      return await getTranscriptMethod2(videoId);\n    } catch (error2) {\n      console.log('Method 2 failed, falling back to description...');\n      // Fallback: Use video description\n      return await getDescriptionFallback(videoId);\n    }\n  }\n}\n\nasync function getTranscriptMethod1(videoId) {\n  const transcript = await YoutubeTranscript.fetchTranscript(videoId);\n  if (!transcript || transcript.length === 0) {\n    throw new Error('No transcript found with method 1');\n  }\n  \n  // Format transcript\n  return formatTranscript(transcript);\n}\n\nasync function getTranscriptMethod2(videoId) {\n  const captions = await getSubtitles({\n    videoID: videoId,\n    lang: 'en' // Try English first\n  });\n  \n  if (!captions || captions.length === 0) {\n    // Try auto-generated captions\n    const autoCaptions = await getSubtitles({\n      videoID: videoId,\n      lang: 'en', \n      auto: true\n    });\n    \n    if (!autoCaptions || autoCaptions.length === 0) {\n      throw new Error('No transcript found with method 2');\n    }\n    \n    return formatCaptions(autoCaptions);\n  }\n  \n  return formatCaptions(captions);\n}\n\nasync function getDescriptionFallback(videoId) {\n  const metadata = await getVideoMetadata(videoId);\n  return {\n    text: `[No transcript available] Video description:\\n\\n${metadata.description}`,\n    hasTranscript: false\n  };\n}\n\nfunction formatTranscript(transcript) {\n  const formattedText = transcript\n    .map(item => `[${formatTimestamp(item.offset)}] ${item.text}`)\n    .join('\\n');\n  \n  return {\n    text: formattedText,\n    hasTranscript: true,\n    segments: transcript\n  };\n}\n\nfunction formatCaptions(captions) {\n  const formattedText = captions\n    .map(item => `[${item.start}] ${item.text}`)\n    .join('\\n');\n  \n  return {\n    text: formattedText,\n    hasTranscript: true,\n    segments: captions\n  };\n}\n\nfunction formatTimestamp(milliseconds) {\n  const seconds = Math.floor(milliseconds / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n}\n\nmodule.exports = {\n  getTranscript\n};\n```\n3. Add language detection and support for multiple languages\n4. Implement timestamp formatting for readability\n5. Create graceful fallback to description-based analysis\n6. Add transcript caching to improve performance\n7. Implement error handling for each extraction method",
        "testStrategy": "1. Test transcript extraction with videos known to have captions\n2. Test with auto-generated captions\n3. Test fallback to description when no captions available\n4. Verify timestamp formatting is correct\n5. Test with videos in different languages\n6. Validate error handling for each extraction method\n7. Test caching mechanism reduces API calls",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Integrate OpenRouter API for AI Analysis",
        "description": "Implement integration with OpenRouter API to access multiple AI models for content analysis.",
        "details": "1. Create AI service in `/services/ai.js`:\n```javascript\nconst axios = require('axios');\n\nasync function analyzeContent(content, options) {\n  const {\n    model = 'gpt-3.5-turbo',\n    promptTemplate,\n    tokenLimit = 6000,\n    videoInfo\n  } = options;\n  \n  try {\n    // Prepare the prompt with video metadata and transcript\n    const prompt = preparePrompt(promptTemplate, videoInfo, content, tokenLimit);\n    \n    // Call OpenRouter API\n    const response = await axios.post(\n      'https://openrouter.ai/api/v1/chat/completions',\n      {\n        model: model,\n        messages: [\n          { role: 'system', content: 'You are a helpful assistant that analyzes YouTube videos.' },\n          { role: 'user', content: prompt }\n        ],\n        max_tokens: Math.min(tokenLimit, getModelMaxTokens(model))\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,\n          'HTTP-Referer': process.env.APP_URL || 'http://localhost:3000',\n          'X-Title': 'YouTube Video Research App'\n        }\n      }\n    );\n    \n    return {\n      analysis: response.data.choices[0].message.content,\n      modelUsed: model,\n      promptUsed: promptTemplate,\n      tokenLimit: tokenLimit,\n      promptText: prompt\n    };\n  } catch (error) {\n    console.error('OpenRouter API error:', error.response?.data || error.message);\n    throw new Error(`AI analysis failed: ${error.response?.data?.error?.message || error.message}`);\n  }\n}\n\nfunction preparePrompt(templateName, videoInfo, transcript, tokenLimit) {\n  // Load the template\n  const template = getPromptTemplate(templateName);\n  \n  // Replace placeholders with actual data\n  let prompt = template\n    .replace('{{VIDEO_TITLE}}', videoInfo.title)\n    .replace('{{CHANNEL_NAME}}', videoInfo.channel)\n    .replace('{{PUBLISH_DATE}}', new Date(videoInfo.publishedAt).toLocaleDateString())\n    .replace('{{VIEW_COUNT}}', videoInfo.viewCount)\n    .replace('{{LIKE_COUNT}}', videoInfo.likeCount || 'N/A')\n    .replace('{{VIDEO_DESCRIPTION}}', videoInfo.description);\n  \n  // Add transcript with token limit consideration\n  const estimatedPromptTokens = prompt.length / 4; // Rough estimate\n  const availableTokens = tokenLimit - estimatedPromptTokens - 500; // Reserve tokens for response\n  \n  if (transcript.hasTranscript) {\n    // Truncate transcript if needed\n    const transcriptText = transcript.text;\n    const estimatedTranscriptTokens = transcriptText.length / 4;\n    \n    if (estimatedTranscriptTokens > availableTokens) {\n      // Truncate transcript to fit token limit\n      const truncatedText = transcriptText.substring(0, Math.floor(availableTokens * 4));\n      prompt = prompt.replace('{{TRANSCRIPT}}', truncatedText + '\\n[Transcript truncated due to length]');\n    } else {\n      prompt = prompt.replace('{{TRANSCRIPT}}', transcriptText);\n    }\n  } else {\n    prompt = prompt.replace('{{TRANSCRIPT}}', '[No transcript available]\\n' + transcript.text);\n  }\n  \n  return prompt;\n}\n\nfunction getPromptTemplate(templateName) {\n  // In a real implementation, these would be loaded from files\n  const templates = {\n    'general': `# YouTube Video Analysis Request\\n\\nPlease analyze the following YouTube video:\\n\\n## Video Information\\n- Title: {{VIDEO_TITLE}}\\n- Channel: {{CHANNEL_NAME}}\\n- Published: {{PUBLISH_DATE}}\\n- Views: {{VIEW_COUNT}}\\n- Likes: {{LIKE_COUNT}}\\n\\n## Video Description\\n{{VIDEO_DESCRIPTION}}\\n\\n## Transcript\\n{{TRANSCRIPT}}\\n\\n## Analysis Instructions\\nPlease provide a comprehensive analysis of this video including:\\n1. A concise summary of the main points\\n2. Key insights and takeaways\\n3. Structure and content organization\\n4. Target audience analysis\\n5. Quality assessment\\n\\nFormat your response in markdown with clear headings and bullet points.`,\n    'tutorial': `# YouTube Tutorial Analysis Request\\n\\nPlease analyze the following tutorial video:\\n\\n## Video Information\\n- Title: {{VIDEO_TITLE}}\\n- Channel: {{CHANNEL_NAME}}\\n- Published: {{PUBLISH_DATE}}\\n- Views: {{VIEW_COUNT}}\\n- Likes: {{LIKE_COUNT}}\\n\\n## Video Description\\n{{VIDEO_DESCRIPTION}}\\n\\n## Transcript\\n{{TRANSCRIPT}}\\n\\n## Analysis Instructions\\nPlease provide a comprehensive analysis of this tutorial including:\\n1. A step-by-step breakdown of the tutorial process\\n2. Required tools, materials, or prerequisites\\n3. Key techniques or methods taught\\n4. Common pitfalls or challenges mentioned\\n5. Alternative approaches suggested\\n\\nFormat your response in markdown with clear headings, numbered steps, and code blocks where appropriate.`,\n    'review': `# YouTube Product Review Analysis Request\\n\\nPlease analyze the following product review video:\\n\\n## Video Information\\n- Title: {{VIDEO_TITLE}}\\n- Channel: {{CHANNEL_NAME}}\\n- Published: {{PUBLISH_DATE}}\\n- Views: {{VIEW_COUNT}}\\n- Likes: {{LIKE_COUNT}}\\n\\n## Video Description\\n{{VIDEO_DESCRIPTION}}\\n\\n## Transcript\\n{{TRANSCRIPT}}\\n\\n## Analysis Instructions\\nPlease provide a comprehensive analysis of this product review including:\\n1. Product specifications and features discussed\\n2. Pros and cons mentioned by the reviewer\\n3. Comparisons to competing products\\n4. Overall verdict and rating\\n5. User cases and recommendations\\n\\nFormat your response in markdown with clear headings, tables for comparisons, and bullet points for pros/cons.`\n  };\n  \n  return templates[templateName] || templates['general'];\n}\n\nfunction getModelMaxTokens(model) {\n  // Maximum context lengths for different models\n  const modelLimits = {\n    'gpt-3.5-turbo': 16385,\n    'gpt-4': 8192,\n    'claude-2': 100000,\n    'anthropic/claude-2': 100000\n  };\n  \n  return modelLimits[model] || 8000; // Default fallback\n}\n\nmodule.exports = {\n  analyzeContent\n};\n```\n2. Create API route for analysis in `/routes/analyze.js`\n3. Implement token limit handling and optimization\n4. Add support for multiple AI models with appropriate configurations\n5. Create prompt template system with placeholder replacement\n6. Implement error handling for API failures\n7. Add cost estimation based on token usage",
        "testStrategy": "1. Test with different AI models (GPT-3.5, GPT-4, Claude)\n2. Verify token limit handling with large transcripts\n3. Test prompt template system with different templates\n4. Validate error handling for API failures\n5. Test with videos of varying lengths and content types\n6. Verify cost estimation accuracy",
        "priority": "high",
        "dependencies": [
          1,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Analysis API Endpoint",
        "description": "Create the main API endpoint that orchestrates the video analysis process, combining YouTube metadata, transcript extraction, and AI analysis.",
        "details": "1. Create analysis route in `/routes/analyze.js`:\n```javascript\nconst express = require('express');\nconst router = express.Router();\nconst { extractVideoId, getVideoMetadata } = require('../services/youtube');\nconst { getTranscript } = require('../services/transcript');\nconst { analyzeContent } = require('../services/ai');\n\nrouter.post('/', async (req, res) => {\n  try {\n    const { url, model = 'gpt-3.5-turbo', promptTemplate = 'general', tokenLimit = 6000 } = req.body;\n    \n    if (!url) {\n      return res.status(400).json({ message: 'YouTube URL is required' });\n    }\n    \n    // Extract video ID from URL\n    const videoId = extractVideoId(url);\n    \n    // Get video metadata\n    const videoInfo = await getVideoMetadata(videoId);\n    \n    // Get transcript\n    const transcript = await getTranscript(videoId);\n    \n    // Analyze content with AI\n    const analysisResult = await analyzeContent(transcript, {\n      model,\n      promptTemplate,\n      tokenLimit: parseInt(tokenLimit),\n      videoInfo\n    });\n    \n    // Return combined result\n    res.json({\n      videoInfo,\n      analysis: analysisResult.analysis,\n      transcript: transcript.text,\n      hasTranscript: transcript.hasTranscript,\n      modelUsed: analysisResult.modelUsed,\n      promptUsed: analysisResult.promptUsed,\n      tokenLimit: analysisResult.tokenLimit\n    });\n  } catch (error) {\n    console.error('Analysis error:', error);\n    res.status(500).json({ message: error.message });\n  }\n});\n\nmodule.exports = router;\n```\n2. Register the route in `server.js`:\n```javascript\nconst analyzeRoutes = require('./routes/analyze');\napp.use('/api/analyze', analyzeRoutes);\n```\n3. Implement request validation and sanitization\n4. Add error handling for each step of the process\n5. Implement request timeout handling for long-running analyses\n6. Add logging for debugging and monitoring\n7. Implement rate limiting to prevent abuse",
        "testStrategy": "1. Test with various YouTube URLs and video types\n2. Verify error handling for each step of the process\n3. Test with different AI models and token limits\n4. Validate response format and content\n5. Test timeout handling for long-running analyses\n6. Verify rate limiting functionality",
        "priority": "high",
        "dependencies": [
          2,
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Custom Prompts System",
        "description": "Create a system for managing and using custom analysis prompts with template placeholders.",
        "details": "1. Create prompts directory structure:\n```\n/prompts\n  /default\n    general.md\n    tutorial.md\n    review.md\n  /custom\n    # User-added prompts will go here\n```\n\n2. Create default prompt templates as markdown files\n3. Implement prompt loading service in `/services/prompts.js`:\n```javascript\nconst fs = require('fs').promises;\nconst path = require('path');\n\nlet promptCache = {};\nlet lastCacheUpdate = 0;\nconst CACHE_TTL = 60 * 1000; // 1 minute\n\nasync function loadPrompts() {\n  const now = Date.now();\n  \n  // Return cached prompts if still valid\n  if (Object.keys(promptCache).length > 0 && now - lastCacheUpdate < CACHE_TTL) {\n    return promptCache;\n  }\n  \n  const prompts = {};\n  \n  // Load default prompts\n  const defaultPromptsDir = path.join(__dirname, '../prompts/default');\n  const defaultPromptFiles = await fs.readdir(defaultPromptsDir);\n  \n  for (const file of defaultPromptFiles) {\n    if (file.endsWith('.md')) {\n      const name = file.replace('.md', '');\n      const content = await fs.readFile(path.join(defaultPromptsDir, file), 'utf8');\n      prompts[name] = {\n        name,\n        content,\n        isDefault: true\n      };\n    }\n  }\n  \n  // Load custom prompts\n  try {\n    const customPromptsDir = path.join(__dirname, '../prompts/custom');\n    const customPromptFiles = await fs.readdir(customPromptsDir);\n    \n    for (const file of customPromptFiles) {\n      if (file.endsWith('.md')) {\n        const name = file.replace('.md', '');\n        const content = await fs.readFile(path.join(customPromptsDir, file), 'utf8');\n        prompts[name] = {\n          name,\n          content,\n          isDefault: false\n        };\n      }\n    }\n  } catch (error) {\n    // Create custom directory if it doesn't exist\n    if (error.code === 'ENOENT') {\n      await fs.mkdir(path.join(__dirname, '../prompts/custom'), { recursive: true });\n    } else {\n      console.error('Error loading custom prompts:', error);\n    }\n  }\n  \n  // Update cache\n  promptCache = prompts;\n  lastCacheUpdate = now;\n  \n  return prompts;\n}\n\nasync function getPromptContent(promptName) {\n  const prompts = await loadPrompts();\n  return prompts[promptName]?.content || prompts['general'].content;\n}\n\nasync function addCustomPrompt(name, content) {\n  const sanitizedName = name.replace(/[^a-z0-9-_]/gi, '');\n  const promptPath = path.join(__dirname, '../prompts/custom', `${sanitizedName}.md`);\n  \n  await fs.writeFile(promptPath, content, 'utf8');\n  \n  // Invalidate cache\n  lastCacheUpdate = 0;\n  \n  return sanitizedName;\n}\n\nasync function getAvailablePrompts() {\n  const prompts = await loadPrompts();\n  return Object.values(prompts).map(prompt => ({\n    name: prompt.name,\n    isDefault: prompt.isDefault\n  }));\n}\n\nmodule.exports = {\n  getPromptContent,\n  addCustomPrompt,\n  getAvailablePrompts\n};\n```\n4. Create API endpoints for prompt management:\n   - GET `/api/prompts` - List available prompts\n   - POST `/api/prompts` - Add custom prompt\n   - GET `/api/prompts/:name` - Get prompt content\n5. Update AI service to use the prompt system\n6. Add frontend interface for prompt selection and management\n7. Implement placeholder system for dynamic content insertion",
        "testStrategy": "1. Test loading default prompts\n2. Verify custom prompt creation and loading\n3. Test prompt caching mechanism\n4. Validate placeholder replacement functionality\n5. Test API endpoints for prompt management\n6. Verify frontend prompt selection interface",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement File Download System",
        "description": "Create a system for generating and downloading analysis reports, transcripts, and other file formats.",
        "details": "1. Create download service in `/services/download.js`:\n```javascript\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\nconst crypto = require('crypto');\n\n// Create temporary directory for downloads\nconst tempDir = path.join(os.tmpdir(), 'youtube-research-app');\nif (!fs.existsSync(tempDir)) {\n  fs.mkdirSync(tempDir, { recursive: true });\n}\n\n// Clean up old files periodically\nsetInterval(() => {\n  const now = Date.now();\n  fs.readdir(tempDir, (err, files) => {\n    if (err) return;\n    \n    files.forEach(file => {\n      const filePath = path.join(tempDir, file);\n      fs.stat(filePath, (err, stats) => {\n        if (err) return;\n        \n        // Remove files older than 1 hour\n        if (now - stats.mtime.getTime() > 60 * 60 * 1000) {\n          fs.unlink(filePath, () => {});\n        }\n      });\n    });\n  });\n}, 30 * 60 * 1000); // Run every 30 minutes\n\nfunction sanitizeFilename(name) {\n  return name\n    .replace(/[^a-z0-9]/gi, '_')\n    .toLowerCase()\n    .substring(0, 100); // Limit length\n}\n\nasync function createDownloadFile(content, filename, contentType) {\n  // Generate unique ID for the file\n  const fileId = crypto.randomBytes(16).toString('hex');\n  const sanitizedName = sanitizeFilename(filename);\n  const fullFilename = `${sanitizedName}-${fileId}`;\n  const filePath = path.join(tempDir, fullFilename);\n  \n  // Write content to file\n  fs.writeFileSync(filePath, content);\n  \n  return {\n    id: fileId,\n    filename: sanitizedName,\n    path: filePath,\n    contentType\n  };\n}\n\nfunction createMarkdownReport(data) {\n  const { videoInfo, analysis, hasTranscript, modelUsed, promptUsed } = data;\n  \n  // Format date\n  const publishDate = new Date(videoInfo.publishedAt).toLocaleDateString();\n  const analysisDate = new Date().toLocaleDateString();\n  \n  // Create markdown content\n  const markdown = `# Analysis: ${videoInfo.title}\n\n## Video Information\n- **Title:** ${videoInfo.title}\n- **Channel:** ${videoInfo.channel}\n- **Published:** ${publishDate}\n- **Views:** ${Number(videoInfo.viewCount).toLocaleString()}\n- **Likes:** ${videoInfo.likeCount ? Number(videoInfo.likeCount).toLocaleString() : 'N/A'}\n- **URL:** https://www.youtube.com/watch?v=${videoInfo.id}\n\n## Analysis\n*Generated on ${analysisDate} using ${modelUsed} with the \"${promptUsed}\" template.*\n\n${analysis}\n\n---\n\n*Generated by YouTube Video Research App*`;\n  \n  return markdown;\n}\n\nmodule.exports = {\n  createDownloadFile,\n  createMarkdownReport,\n  sanitizeFilename\n};\n```\n2. Create download routes in `/routes/download.js`:\n```javascript\nconst express = require('express');\nconst router = express.Router();\nconst path = require('path');\nconst fs = require('fs');\nconst { createDownloadFile, createMarkdownReport } = require('../services/download');\n\n// Generate markdown report\nrouter.post('/markdown', async (req, res) => {\n  try {\n    const data = req.body;\n    \n    if (!data.videoInfo || !data.analysis) {\n      return res.status(400).json({ message: 'Missing required data' });\n    }\n    \n    // Generate markdown content\n    const markdown = createMarkdownReport(data);\n    \n    // Create download file\n    const filename = `${data.videoInfo.title}-analysis.md`;\n    const file = await createDownloadFile(markdown, filename, 'text/markdown');\n    \n    res.json({\n      downloadId: file.id,\n      filename: file.filename\n    });\n  } catch (error) {\n    console.error('Download generation error:', error);\n    res.status(500).json({ message: error.message });\n  }\n});\n\n// Download file by ID\nrouter.get('/:id/:filename', (req, res) => {\n  try {\n    const { id, filename } = req.params;\n    const tempDir = path.join(os.tmpdir(), 'youtube-research-app');\n    \n    // Find the file with the matching ID\n    const files = fs.readdirSync(tempDir);\n    const targetFile = files.find(file => file.includes(id));\n    \n    if (!targetFile) {\n      return res.status(404).json({ message: 'File not found or expired' });\n    }\n    \n    const filePath = path.join(tempDir, targetFile);\n    \n    // Determine content type\n    let contentType = 'text/plain';\n    if (filename.endsWith('.md')) {\n      contentType = 'text/markdown';\n    } else if (filename.endsWith('.json')) {\n      contentType = 'application/json';\n    }\n    \n    res.setHeader('Content-Type', contentType);\n    res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n    \n    // Stream the file\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n  } catch (error) {\n    console.error('Download error:', error);\n    res.status(500).json({ message: error.message });\n  }\n});\n\nmodule.exports = router;\n```\n3. Register download routes in `server.js`\n4. Implement frontend download functionality\n5. Add support for multiple file formats (markdown, plain text, JSON)\n6. Implement file cleanup for temporary files\n7. Add proper content type headers and file naming",
        "testStrategy": "1. Test markdown report generation\n2. Verify file download functionality\n3. Test with different file formats\n4. Validate file cleanup mechanism\n5. Test with large files\n6. Verify proper content type headers and file naming",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Notion API Integration",
        "description": "Create a system for saving analysis reports directly to Notion databases with structured content and two-tier organization.",
        "details": "1. Install Notion client: `npm install @notionhq/client@2.2.14`\n2. Create Notion service in `/services/notion.js`:\n```javascript\nconst { Client } = require('@notionhq/client');\n\nlet notionClient = null;\n\nfunction initializeNotionClient(token) {\n  notionClient = new Client({ auth: token });\n  return notionClient;\n}\n\nasync function getDatabases(token) {\n  const client = token ? initializeNotionClient(token) : notionClient;\n  \n  if (!client) {\n    throw new Error('Notion client not initialized');\n  }\n  \n  try {\n    const response = await client.search({\n      filter: {\n        property: 'object',\n        value: 'database'\n      }\n    });\n    \n    return response.results.map(db => ({\n      id: db.id,\n      title: db.title[0]?.plain_text || 'Untitled Database',\n      icon: db.icon?.emoji || null\n    }));\n  } catch (error) {\n    console.error('Notion API error:', error);\n    throw new Error(`Notion API error: ${error.message}`);\n  }\n}\n\nasync function saveToNotion(databaseId, data) {\n  if (!notionClient) {\n    throw new Error('Notion client not initialized');\n  }\n  \n  const { videoInfo, analysis, hasTranscript, modelUsed, promptUsed } = data;\n  \n  try {\n    // Create child page with detailed analysis\n    const childPage = await notionClient.pages.create({\n      parent: { type: 'workspace', workspace: true },\n      properties: {\n        title: [\n          {\n            type: 'text',\n            text: {\n              content: `Analysis: ${videoInfo.title}`\n            }\n          }\n        ]\n      },\n      children: convertMarkdownToBlocks(analysis)\n    });\n    \n    // Create main database entry\n    const mainEntry = await notionClient.pages.create({\n      parent: { database_id: databaseId },\n      properties: {\n        'Title': {\n          title: [\n            {\n              text: {\n                content: videoInfo.title\n              }\n            }\n          ]\n        },\n        'URL': {\n          url: `https://www.youtube.com/watch?v=${videoInfo.id}`\n        },\n        'Channel': {\n          rich_text: [\n            {\n              text: {\n                content: videoInfo.channel\n              }\n            }\n          ]\n        },\n        'Published Date': {\n          date: {\n            start: new Date(videoInfo.publishedAt).toISOString()\n          }\n        },\n        'Views': {\n          number: parseInt(videoInfo.viewCount)\n        },\n        'Likes': {\n          number: videoInfo.likeCount ? parseInt(videoInfo.likeCount) : 0\n        },\n        'Content': {\n          url: `https://notion.so/${childPage.id.replace(/-/g, '')}`\n        }\n      }\n    });\n    \n    return {\n      mainEntryId: mainEntry.id,\n      childPageId: childPage.id,\n      mainEntryUrl: `https://notion.so/${mainEntry.id.replace(/-/g, '')}`,\n      childPageUrl: `https://notion.so/${childPage.id.replace(/-/g, '')}`\n    };\n  } catch (error) {\n    console.error('Notion save error:', error);\n    throw new Error(`Failed to save to Notion: ${error.message}`);\n  }\n}\n\nfunction convertMarkdownToBlocks(markdown) {\n  // This is a simplified version - a real implementation would use a proper markdown parser\n  const blocks = [];\n  const lines = markdown.split('\\n');\n  \n  let currentBlock = null;\n  \n  for (const line of lines) {\n    // Heading 1\n    if (line.startsWith('# ')) {\n      blocks.push({\n        object: 'block',\n        type: 'heading_1',\n        heading_1: {\n          rich_text: [{\n            type: 'text',\n            text: { content: line.substring(2) }\n          }]\n        }\n      });\n    }\n    // Heading 2\n    else if (line.startsWith('## ')) {\n      blocks.push({\n        object: 'block',\n        type: 'heading_2',\n        heading_2: {\n          rich_text: [{\n            type: 'text',\n            text: { content: line.substring(3) }\n          }]\n        }\n      });\n    }\n    // Heading 3\n    else if (line.startsWith('### ')) {\n      blocks.push({\n        object: 'block',\n        type: 'heading_3',\n        heading_3: {\n          rich_text: [{\n            type: 'text',\n            text: { content: line.substring(4) }\n          }]\n        }\n      });\n    }\n    // Bullet list\n    else if (line.startsWith('- ')) {\n      blocks.push({\n        object: 'block',\n        type: 'bulleted_list_item',\n        bulleted_list_item: {\n          rich_text: [{\n            type: 'text',\n            text: { content: line.substring(2) }\n          }]\n        }\n      });\n    }\n    // Empty line\n    else if (line.trim() === '') {\n      // Skip empty lines or add a divider\n      if (blocks.length > 0 && blocks[blocks.length - 1].type !== 'divider') {\n        blocks.push({\n          object: 'block',\n          type: 'paragraph',\n          paragraph: {\n            rich_text: []\n          }\n        });\n      }\n    }\n    // Regular paragraph\n    else {\n      blocks.push({\n        object: 'block',\n        type: 'paragraph',\n        paragraph: {\n          rich_text: [{\n            type: 'text',\n            text: { content: line }\n          }]\n        }\n      });\n    }\n  }\n  \n  return blocks;\n}\n\nmodule.exports = {\n  initializeNotionClient,\n  getDatabases,\n  saveToNotion\n};\n```\n3. Create Notion routes in `/routes/notion.js`:\n```javascript\nconst express = require('express');\nconst router = express.Router();\nconst { initializeNotionClient, getDatabases, saveToNotion } = require('../services/notion');\n\n// Initialize Notion client\nrouter.post('/connect', async (req, res) => {\n  try {\n    const { token } = req.body;\n    \n    if (!token) {\n      return res.status(400).json({ message: 'Notion token is required' });\n    }\n    \n    // Initialize client and test connection\n    initializeNotionClient(token);\n    const databases = await getDatabases();\n    \n    res.json({\n      connected: true,\n      databases\n    });\n  } catch (error) {\n    console.error('Notion connection error:', error);\n    res.status(500).json({\n      connected: false,\n      message: error.message\n    });\n  }\n});\n\n// Get available databases\nrouter.get('/databases', async (req, res) => {\n  try {\n    const databases = await getDatabases();\n    res.json({ databases });\n  } catch (error) {\n    console.error('Notion databases error:', error);\n    res.status(500).json({ message: error.message });\n  }\n});\n\n// Save to Notion\nrouter.post('/save', async (req, res) => {\n  try {\n    const { databaseId, data } = req.body;\n    \n    if (!databaseId) {\n      return res.status(400).json({ message: 'Database ID is required' });\n    }\n    \n    if (!data || !data.videoInfo || !data.analysis) {\n      return res.status(400).json({ message: 'Analysis data is required' });\n    }\n    \n    const result = await saveToNotion(databaseId, data);\n    res.json(result);\n  } catch (error) {\n    console.error('Notion save error:', error);\n    res.status(500).json({ message: error.message });\n  }\n});\n\nmodule.exports = router;\n```\n4. Register Notion routes in `server.js`\n5. Implement frontend Notion integration UI\n6. Create markdown to Notion blocks converter\n7. Implement database property mapping\n8. Add connection status management",
        "testStrategy": "1. Test Notion client initialization\n2. Verify database listing functionality\n3. Test saving content to Notion\n4. Validate markdown to Notion blocks conversion\n5. Test with different database schemas\n6. Verify two-tier structure creation",
        "priority": "medium",
        "dependencies": [
          6,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Enhance Frontend with Advanced UI Features",
        "description": "Improve the frontend interface with advanced features like real-time feedback, model search, favorites, and responsive design.",
        "details": "1. Update `/public/styles.css` with modern CSS:\n```css\n:root {\n  --primary-color: #4f46e5;\n  --primary-hover: #4338ca;\n  --secondary-color: #10b981;\n  --text-color: #1f2937;\n  --light-text: #6b7280;\n  --background: #ffffff;\n  --light-background: #f9fafb;\n  --border-color: #e5e7eb;\n  --error-color: #ef4444;\n  --success-color: #10b981;\n  --warning-color: #f59e0b;\n  --radius: 8px;\n  --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n}\n\n* {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n\nbody {\n  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n  color: var(--text-color);\n  background-color: var(--light-background);\n  line-height: 1.5;\n}\n\nheader {\n  background-color: var(--primary-color);\n  color: white;\n  padding: 1.5rem;\n  text-align: center;\n  box-shadow: var(--shadow);\n}\n\nmain {\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 2rem 1rem;\n}\n\n.form-group {\n  margin-bottom: 1.5rem;\n}\n\nlabel {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n}\n\ninput, select {\n  width: 100%;\n  padding: 0.75rem;\n  border: 1px solid var(--border-color);\n  border-radius: var(--radius);\n  font-size: 1rem;\n  transition: border-color 0.2s;\n}\n\ninput:focus, select:focus {\n  outline: none;\n  border-color: var(--primary-color);\n  box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);\n}\n\nbutton {\n  background-color: var(--primary-color);\n  color: white;\n  border: none;\n  border-radius: var(--radius);\n  padding: 0.75rem 1.5rem;\n  font-size: 1rem;\n  font-weight: 500;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\nbutton:hover {\n  background-color: var(--primary-hover);\n}\n\nbutton:disabled {\n  opacity: 0.7;\n  cursor: not-allowed;\n}\n\n#input-section {\n  background-color: var(--background);\n  padding: 2rem;\n  border-radius: var(--radius);\n  box-shadow: var(--shadow);\n  margin-bottom: 2rem;\n}\n\n#results-section {\n  background-color: var(--background);\n  padding: 2rem;\n  border-radius: var(--radius);\n  box-shadow: var(--shadow);\n  margin-top: 2rem;\n}\n\n.hidden {\n  display: none;\n}\n\n#status-container {\n  margin-top: 1rem;\n  padding: 1rem;\n  border-radius: var(--radius);\n  background-color: var(--light-background);\n  text-align: center;\n}\n\n#status-message {\n  font-weight: 500;\n}\n\n#status-message.error {\n  color: var(--error-color);\n}\n\n#loading-indicator {\n  display: inline-block;\n  width: 20px;\n  height: 20px;\n  border: 3px solid rgba(79, 70, 229, 0.3);\n  border-radius: 50%;\n  border-top-color: var(--primary-color);\n  animation: spin 1s ease-in-out infinite;\n  margin-left: 0.5rem;\n}\n\n@keyframes spin {\n  to { transform: rotate(360deg); }\n}\n\n.video-header {\n  display: flex;\n  gap: 1.5rem;\n  margin-bottom: 2rem;\n}\n\n.video-header img {\n  width: 240px;\n  border-radius: var(--radius);\n}\n\n.video-details h2 {\n  margin-bottom: 0.5rem;\n}\n\n.video-details p {\n  color: var(--light-text);\n  margin-bottom: 0.25rem;\n}\n\n.markdown-content {\n  line-height: 1.7;\n}\n\n.markdown-content h1 {\n  margin-top: 1.5rem;\n  margin-bottom: 1rem;\n  font-size: 1.8rem;\n}\n\n.markdown-content h2 {\n  margin-top: 1.5rem;\n  margin-bottom: 0.75rem;\n  font-size: 1.5rem;\n}\n\n.markdown-content h3 {\n  margin-top: 1.25rem;\n  margin-bottom: 0.5rem;\n  font-size: 1.25rem;\n}\n\n.markdown-content p {\n  margin-bottom: 1rem;\n}\n\n.markdown-content ul, .markdown-content ol {\n  margin-bottom: 1rem;\n  padding-left: 1.5rem;\n}\n\n.markdown-content li {\n  margin-bottom: 0.5rem;\n}\n\n#download-options {\n  margin-top: 2rem;\n  display: flex;\n  gap: 1rem;\n}\n\n/* Responsive design */\n@media (max-width: 768px) {\n  .video-header {\n    flex-direction: column;\n  }\n  \n  .video-header img {\n    width: 100%;\n    max-width: 320px;\n  }\n  \n  #download-options {\n    flex-direction: column;\n  }\n}\n\n/* Notion integration panel */\n#notion-panel {\n  background-color: var(--background);\n  padding: 2rem;\n  border-radius: var(--radius);\n  box-shadow: var(--shadow);\n  margin-top: 2rem;\n}\n\n.notion-status {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  margin-bottom: 1rem;\n}\n\n.status-indicator {\n  width: 10px;\n  height: 10px;\n  border-radius: 50%;\n}\n\n.status-indicator.connected {\n  background-color: var(--success-color);\n}\n\n.status-indicator.disconnected {\n  background-color: var(--error-color);\n}\n\n.database-selector {\n  margin-top: 1rem;\n}\n```\n2. Enhance frontend JavaScript with advanced features:\n   - Model search and filtering\n   - Favorites functionality\n   - Real-time status updates\n   - Comprehensive error handling\n   - Token limit visualization\n   - Responsive design adjustments\n3. Implement advanced UI components:\n   - Tabbed interface for results\n   - Collapsible sections\n   - Tooltips for guidance\n   - Progress indicators\n   - Notification system\n4. Add keyboard shortcuts and accessibility features\n5. Implement dark mode support\n6. Add animations and transitions for better UX\n7. Implement responsive design for mobile devices",
        "testStrategy": "1. Test responsive design on different screen sizes\n2. Verify model search and filtering functionality\n3. Test favorites system\n4. Validate real-time status updates\n5. Test keyboard shortcuts and accessibility\n6. Verify dark mode functionality\n7. Test animations and transitions",
        "priority": "medium",
        "dependencies": [
          3,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Multiple AI Model Support",
        "description": "Enhance the AI integration to support multiple models from OpenRouter with search, favorites, and cost estimation.",
        "details": "1. Create model service in `/services/models.js`:\n```javascript\nconst axios = require('axios');\n\nlet modelCache = null;\nlet lastCacheUpdate = 0;\nconst CACHE_TTL = 60 * 60 * 1000; // 1 hour\n\nasync function getAvailableModels() {\n  const now = Date.now();\n  \n  // Return cached models if still valid\n  if (modelCache && now - lastCacheUpdate < CACHE_TTL) {\n    return modelCache;\n  }\n  \n  try {\n    const response = await axios.get('https://openrouter.ai/api/v1/models', {\n      headers: {\n        'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,\n        'HTTP-Referer': process.env.APP_URL || 'http://localhost:3000',\n        'X-Title': 'YouTube Video Research App'\n      }\n    });\n    \n    // Process and categorize models\n    const models = response.data.data.map(model => ({\n      id: model.id,\n      name: model.name,\n      description: model.description || '',\n      context_length: model.context_length,\n      pricing: {\n        prompt: model.pricing.prompt,\n        completion: model.pricing.completion\n      },\n      category: categorizeModel(model.id),\n      provider: extractProvider(model.id)\n    }));\n    \n    // Update cache\n    modelCache = models;\n    lastCacheUpdate = now;\n    \n    return models;\n  } catch (error) {\n    console.error('OpenRouter API error:', error.response?.data || error.message);\n    throw new Error(`Failed to fetch models: ${error.response?.data?.error?.message || error.message}`);\n  }\n}\n\nfunction categorizeModel(modelId) {\n  const id = modelId.toLowerCase();\n  if (id.includes('gpt-4')) return 'GPT-4';\n  if (id.includes('gpt-3.5')) return 'GPT-3.5';\n  if (id.includes('claude')) return 'Claude';\n  if (id.includes('gemini')) return 'Gemini';\n  if (id.includes('llama')) return 'Llama';\n  if (id.includes('mistral')) return 'Mistral';\n  return 'Other';\n}\n\nfunction extractProvider(modelId) {\n  const parts = modelId.split('/');\n  return parts.length > 1 ? parts[0] : 'OpenAI';\n}\n\nfunction estimateCost(model, promptTokens, completionTokens) {\n  if (!model || !model.pricing) {\n    return { promptCost: 0, completionCost: 0, totalCost: 0 };\n  }\n  \n  const promptCost = (promptTokens / 1000) * model.pricing.prompt;\n  const completionCost = (completionTokens / 1000) * model.pricing.completion;\n  const totalCost = promptCost + completionCost;\n  \n  return {\n    promptCost,\n    completionCost,\n    totalCost\n  };\n}\n\nmodule.exports = {\n  getAvailableModels,\n  estimateCost\n};\n```\n2. Create models API route in `/routes/models.js`:\n```javascript\nconst express = require('express');\nconst router = express.Router();\nconst { getAvailableModels, estimateCost } = require('../services/models');\n\n// Get available models\nrouter.get('/', async (req, res) => {\n  try {\n    const models = await getAvailableModels();\n    res.json({ models });\n  } catch (error) {\n    console.error('Models API error:', error);\n    res.status(500).json({ message: error.message });\n  }\n});\n\n// Estimate cost\nrouter.post('/estimate-cost', (req, res) => {\n  try {\n    const { modelId, promptTokens, completionTokens } = req.body;\n    \n    if (!modelId || !promptTokens || !completionTokens) {\n      return res.status(400).json({ message: 'Missing required parameters' });\n    }\n    \n    // Find the model\n    const models = modelCache || [];\n    const model = models.find(m => m.id === modelId);\n    \n    if (!model) {\n      return res.status(404).json({ message: 'Model not found' });\n    }\n    \n    const cost = estimateCost(model, promptTokens, completionTokens);\n    res.json(cost);\n  } catch (error) {\n    console.error('Cost estimation error:', error);\n    res.status(500).json({ message: error.message });\n  }\n});\n\nmodule.exports = router;\n```\n3. Register models route in `server.js`\n4. Update AI service to use model information\n5. Implement frontend model selection interface with search and filtering\n6. Add favorites functionality with local storage\n7. Implement cost estimation display",
        "testStrategy": "1. Test model fetching from OpenRouter API\n2. Verify model categorization and filtering\n3. Test cost estimation functionality\n4. Validate favorites system with local storage\n5. Test model search functionality\n6. Verify model information display",
        "priority": "medium",
        "dependencies": [
          5,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Advanced Error Handling and Monitoring",
        "description": "Create a comprehensive error handling system with detailed logging, user-friendly messages, and health monitoring.",
        "details": "1. Create error handling middleware in `/middleware/errorHandler.js`:\n```javascript\nconst errorHandler = (err, req, res, next) => {\n  // Log error\n  console.error('Error:', err);\n  \n  // Determine status code\n  const statusCode = res.statusCode !== 200 ? res.statusCode : 500;\n  \n  // Create user-friendly message\n  let message = err.message;\n  let details = process.env.NODE_ENV === 'development' ? err.stack : null;\n  \n  // Handle specific error types\n  if (err.name === 'ValidationError') {\n    res.status(400);\n    message = 'Validation error: ' + err.message;\n  } else if (err.name === 'UnauthorizedError') {\n    res.status(401);\n    message = 'Authentication error: ' + err.message;\n  } else if (err.code === 'ECONNREFUSED' || err.code === 'ETIMEDOUT') {\n    message = 'Service unavailable. Please try again later.';\n  } else if (err.response) {\n    // API error responses\n    const apiError = err.response.data;\n    message = apiError.error?.message || apiError.message || 'API error';\n    details = process.env.NODE_ENV === 'development' ? apiError : null;\n  }\n  \n  // Send error response\n  res.status(statusCode).json({\n    message,\n    details,\n    stack: process.env.NODE_ENV === 'development' ? err.stack : null\n  });\n};\n\nmodule.exports = errorHandler;\n```\n2. Create not found middleware in `/middleware/notFound.js`:\n```javascript\nconst notFound = (req, res, next) => {\n  const error = new Error(`Not Found - ${req.originalUrl}`);\n  res.status(404);\n  next(error);\n};\n\nmodule.exports = notFound;\n```\n3. Create health monitoring route in `/routes/health.js`:\n```javascript\nconst express = require('express');\nconst router = express.Router();\nconst axios = require('axios');\n\nrouter.get('/', async (req, res) => {\n  try {\n    const services = {\n      server: { status: 'ok' },\n      youtube: await checkYouTubeAPI(),\n      openrouter: await checkOpenRouterAPI(),\n      notion: req.query.notion_token ? await checkNotionAPI(req.query.notion_token) : { status: 'unknown', message: 'No token provided' }\n    };\n    \n    const overallStatus = Object.values(services).every(s => s.status === 'ok') ? 'ok' : 'degraded';\n    \n    res.json({\n      status: overallStatus,\n      timestamp: new Date().toISOString(),\n      services\n    });\n  } catch (error) {\n    console.error('Health check error:', error);\n    res.status(500).json({\n      status: 'error',\n      message: error.message,\n      timestamp: new Date().toISOString()\n    });\n  }\n});\n\nasync function checkYouTubeAPI() {\n  try {\n    // Simple check using a known video ID\n    const response = await axios.get(`https://www.googleapis.com/youtube/v3/videos?id=dQw4w9WgXcQ&part=snippet&key=${process.env.YOUTUBE_API_KEY}`);\n    return { status: 'ok' };\n  } catch (error) {\n    return {\n      status: 'error',\n      message: error.response?.data?.error?.message || error.message\n    };\n  }\n}\n\nasync function checkOpenRouterAPI() {\n  try {\n    const response = await axios.get('https://openrouter.ai/api/v1/models', {\n      headers: {\n        'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,\n        'HTTP-Referer': process.env.APP_URL || 'http://localhost:3000'\n      }\n    });\n    return { status: 'ok' };\n  } catch (error) {\n    return {\n      status: 'error',\n      message: error.response?.data?.error?.message || error.message\n    };\n  }\n}\n\nasync function checkNotionAPI(token) {\n  try {\n    const { Client } = require('@notionhq/client');\n    const notion = new Client({ auth: token });\n    await notion.users.me();\n    return { status: 'ok' };\n  } catch (error) {\n    return {\n      status: 'error',\n      message: error.message\n    };\n  }\n}\n\nmodule.exports = router;\n```\n4. Add middleware to `server.js`:\n```javascript\nconst errorHandler = require('./middleware/errorHandler');\nconst notFound = require('./middleware/notFound');\n\n// Routes\napp.use('/api/health', require('./routes/health'));\n// ... other routes\n\n// Error handling\napp.use(notFound);\napp.use(errorHandler);\n```\n5. Implement frontend error handling with user-friendly messages\n6. Create health monitoring dashboard in frontend\n7. Add request timeout handling for long-running operations",
        "testStrategy": "1. Test error handling with various error types\n2. Verify health monitoring for each service\n3. Test frontend error display\n4. Validate timeout handling\n5. Test with network failures\n6. Verify user-friendly error messages",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Advanced Transcript Processing",
        "description": "Enhance transcript extraction with language detection, formatting, and fallback mechanisms.",
        "details": "1. Install additional packages: `npm install iso-639-1@2.1.15 languagedetect@2.0.0`\n2. Enhance transcript service with language detection:\n```javascript\nconst ISO6391 = require('iso-639-1');\nconst LanguageDetect = require('languagedetect');\nconst lngDetector = new LanguageDetect();\n\nasync function getTranscriptWithLanguage(videoId) {\n  // Try to get available caption tracks\n  const tracks = await getCaptionTracks(videoId);\n  \n  if (tracks && tracks.length > 0) {\n    // Try to find English track first\n    const englishTrack = tracks.find(track => \n      track.language_code === 'en' || \n      track.language_code === 'en-US' || \n      track.language_code === 'en-GB'\n    );\n    \n    if (englishTrack) {\n      return await getTranscriptForTrack(videoId, englishTrack.language_code);\n    }\n    \n    // If no English track, use the first available track\n    return await getTranscriptForTrack(videoId, tracks[0].language_code);\n  }\n  \n  // If no tracks found, try default methods\n  return await getTranscript(videoId);\n}\n\nasync function getCaptionTracks(videoId) {\n  try {\n    // Use youtube-captions-scraper to get available tracks\n    const { getSubtitlesList } = require('youtube-captions-scraper');\n    return await getSubtitlesList({ videoID: videoId });\n  } catch (error) {\n    console.error('Error getting caption tracks:', error);\n    return null;\n  }\n}\n\nasync function getTranscriptForTrack(videoId, languageCode) {\n  try {\n    const { getSubtitles } = require('youtube-captions-scraper');\n    const captions = await getSubtitles({\n      videoID: videoId,\n      lang: languageCode\n    });\n    \n    if (!captions || captions.length === 0) {\n      throw new Error(`No captions found for language: ${languageCode}`);\n    }\n    \n    // Detect language to confirm\n    const text = captions.map(c => c.text).join(' ');\n    const detectedLanguage = detectLanguage(text);\n    \n    return {\n      text: formatCaptions(captions),\n      hasTranscript: true,\n      segments: captions,\n      language: {\n        code: languageCode,\n        name: ISO6391.getName(languageCode.split('-')[0]),\n        detected: detectedLanguage\n      }\n    };\n  } catch (error) {\n    console.error(`Error getting transcript for language ${languageCode}:`, error);\n    throw error;\n  }\n}\n\nfunction detectLanguage(text) {\n  // Only detect if we have enough text\n  if (text.length < 50) return null;\n  \n  try {\n    const detections = lngDetector.detect(text, 2);\n    if (detections && detections.length > 0) {\n      return {\n        code: detections[0][0],\n        confidence: detections[0][1]\n      };\n    }\n    return null;\n  } catch (error) {\n    console.error('Language detection error:', error);\n    return null;\n  }\n}\n\nfunction formatCaptions(captions) {\n  // Group captions by speaker if possible\n  let formattedText = '';\n  let currentSpeaker = null;\n  let currentParagraph = '';\n  \n  for (const caption of captions) {\n    const text = caption.text;\n    const timestamp = formatTimestamp(caption.start);\n    \n    // Check if this might be a new speaker\n    const speakerMatch = text.match(/^([A-Z][a-z]+:)\\s(.+)$/);\n    \n    if (speakerMatch) {\n      // New speaker detected\n      if (currentParagraph) {\n        formattedText += currentParagraph + '\\n\\n';\n        currentParagraph = '';\n      }\n      \n      currentSpeaker = speakerMatch[1];\n      currentParagraph = `[${timestamp}] ${currentSpeaker} ${speakerMatch[2]}`;\n    } else if (text.startsWith('- ') || text.startsWith('• ')) {\n      // List item\n      if (currentParagraph) {\n        formattedText += currentParagraph + '\\n\\n';\n        currentParagraph = '';\n      }\n      formattedText += `[${timestamp}] ${text}\\n`;\n    } else {\n      // Continue current paragraph or start new one\n      if (!currentParagraph) {\n        currentParagraph = `[${timestamp}] ${text}`;\n      } else {\n        // Check if this is likely a continuation\n        if (text.length < 30 || !text.match(/^[A-Z]/) || !currentParagraph.endsWith('.')) {\n          currentParagraph += ' ' + text;\n        } else {\n          formattedText += currentParagraph + '\\n\\n';\n          currentParagraph = `[${timestamp}] ${text}`;\n        }\n      }\n    }\n  }\n  \n  // Add the last paragraph\n  if (currentParagraph) {\n    formattedText += currentParagraph;\n  }\n  \n  return formattedText;\n}\n```\n3. Implement transcript cleaning and formatting\n4. Add support for multiple languages\n5. Enhance fallback mechanisms\n6. Implement speaker detection and paragraph formatting\n7. Add transcript summarization for very long transcripts",
        "testStrategy": "1. Test language detection with multilingual videos\n2. Verify transcript formatting with different video types\n3. Test speaker detection and paragraph formatting\n4. Validate fallback mechanisms\n5. Test with videos that have multiple caption tracks\n6. Verify transcript summarization for long videos",
        "priority": "low",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Apify Integration for Additional Transcript Methods",
        "description": "Integrate with Apify API as an additional fallback method for transcript extraction.",
        "details": "1. Install Apify client: `npm install apify-client@2.12.6`\n2. Create Apify service in `/services/apify.js`:\n```javascript\nconst { ApifyClient } = require('apify-client');\n\nlet apifyClient = null;\n\nfunction initializeApifyClient() {\n  if (!process.env.APIFY_API_TOKEN) {\n    throw new Error('Apify API token not configured');\n  }\n  \n  apifyClient = new ApifyClient({\n    token: process.env.APIFY_API_TOKEN,\n  });\n  \n  return apifyClient;\n}\n\nasync function getTranscriptViaApify(videoId) {\n  if (!apifyClient) {\n    initializeApifyClient();\n  }\n  \n  try {\n    // Start the YouTube Transcripts actor\n    const run = await apifyClient.actor('junglee/youtube-transcripts').call({\n      videoId: videoId,\n      maxWaitSecs: 60\n    });\n    \n    // Get the dataset items\n    const { items } = await apifyClient.dataset(run.defaultDatasetId).listItems();\n    \n    if (!items || items.length === 0) {\n      throw new Error('No transcript found via Apify');\n    }\n    \n    const transcript = items[0];\n    \n    if (!transcript.transcript || transcript.transcript.length === 0) {\n      throw new Error('Empty transcript returned from Apify');\n    }\n    \n    // Format the transcript\n    return {\n      text: formatApifyTranscript(transcript),\n      hasTranscript: true,\n      segments: transcript.transcript,\n      language: {\n        code: transcript.language || 'unknown',\n        name: transcript.language || 'Unknown',\n        detected: null\n      }\n    };\n  } catch (error) {\n    console.error('Apify API error:', error);\n    throw new Error(`Apify transcript extraction failed: ${error.message}`);\n  }\n}\n\nfunction formatApifyTranscript(transcript) {\n  if (!transcript.transcript) return '';\n  \n  return transcript.transcript\n    .map(segment => `[${formatTimestamp(segment.offset / 1000)}] ${segment.text}`)\n    .join('\\n');\n}\n\nfunction formatTimestamp(seconds) {\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = Math.floor(seconds % 60);\n  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n}\n\nmodule.exports = {\n  initializeApifyClient,\n  getTranscriptViaApify\n};\n```\n3. Update transcript service to include Apify as a fallback method:\n```javascript\nasync function getTranscript(videoId) {\n  // Try multiple methods in sequence\n  try {\n    // Method 1: youtube-transcript package\n    return await getTranscriptMethod1(videoId);\n  } catch (error1) {\n    console.log('Method 1 failed, trying method 2...');\n    try {\n      // Method 2: youtube-captions-scraper\n      return await getTranscriptMethod2(videoId);\n    } catch (error2) {\n      console.log('Method 2 failed, trying Apify...');\n      try {\n        // Method 3: Apify integration\n        if (process.env.APIFY_API_TOKEN) {\n          return await getTranscriptViaApify(videoId);\n        } else {\n          throw new Error('Apify API token not configured');\n        }\n      } catch (error3) {\n        console.log('All transcript methods failed, falling back to description...');\n        // Fallback: Use video description\n        return await getDescriptionFallback(videoId);\n      }\n    }\n  }\n}\n```\n4. Add Apify configuration to environment variables\n5. Implement error handling for Apify API\n6. Add caching for Apify results\n7. Create fallback chain with proper logging",
        "testStrategy": "1. Test Apify integration with various video types\n2. Verify fallback chain works correctly\n3. Test error handling for Apify API\n4. Validate caching mechanism\n5. Test with videos that fail other extraction methods\n6. Verify transcript formatting from Apify",
        "priority": "low",
        "dependencies": [
          13
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Create Comprehensive Documentation and Testing",
        "description": "Develop comprehensive documentation, testing, and deployment instructions for the application.",
        "details": "1. Create README.md with detailed setup and usage instructions:\n```markdown\n# YouTube Video Research App\n\nA powerful web application that analyzes YouTube videos and generates comprehensive markdown reports with AI-driven insights.\n\n## Features\n\n- Extract metadata, transcripts, and descriptions from any YouTube video\n- Generate AI-powered analysis using multiple models (GPT-3.5, GPT-4, Claude, etc.)\n- Use specialized templates for different video types\n- Save notes directly to Notion databases\n- Download analysis in multiple formats\n- Modern, responsive web interface\n\n## Setup Instructions\n\n### Prerequisites\n\n- Node.js v14 or higher\n- npm or yarn\n- API keys for required services\n\n### Installation\n\n1. Clone the repository:\n   ```bash\n   git clone https://github.com/yourusername/youtube-research-app.git\n   cd youtube-research-app\n   ```\n\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Create a `.env` file in the root directory with the following variables:\n   ```\n   PORT=3000\n   YOUTUBE_API_KEY=your_youtube_api_key\n   OPENROUTER_API_KEY=your_openrouter_api_key\n   APIFY_API_TOKEN=your_apify_token (optional)\n   APP_URL=http://localhost:3000\n   NODE_ENV=development\n   ```\n\n4. Start the development server:\n   ```bash\n   npm run dev\n   ```\n\n5. Open your browser and navigate to `http://localhost:3000`\n\n### API Keys\n\n- **YouTube API Key**: Create a project in the [Google Cloud Console](https://console.cloud.google.com/), enable the YouTube Data API v3, and generate an API key.\n- **OpenRouter API Key**: Sign up at [OpenRouter](https://openrouter.ai/) and create an API key.\n- **Apify Token** (optional): Sign up at [Apify](https://apify.com/) and get your API token.\n\n## Usage Guide\n\n### Basic Analysis\n\n1. Enter a YouTube URL in the input field\n2. Select an AI model (GPT-3.5 Turbo recommended for most cases)\n3. Choose an analysis template\n4. Set the token limit for analysis depth\n5. Click \"Analyze Video\"\n6. View the generated analysis\n7. Download the report or save to Notion\n\n### Notion Integration\n\n1. Create a Notion integration at [Notion Developers](https://www.notion.so/my-integrations)\n2. Share your database with the integration\n3. Copy the integration token\n4. Enter the token in the app's Notion settings\n5. Select your target database\n6. Analyze videos and save directly to Notion\n\n### Custom Prompts\n\n1. Create a markdown file with your custom prompt template\n2. Use placeholders like `{{VIDEO_TITLE}}`, `{{CHANNEL_NAME}}`, etc.\n3. Place the file in the `prompts/custom` directory\n4. Reload prompts in the app\n5. Select your custom prompt from the dropdown\n\n## Development\n\n### Project Structure\n\n```\n/\n├── public/              # Frontend assets\n│   ├── index.html      # Main HTML file\n│   ├── script.js       # Frontend JavaScript\n│   └── styles.css      # CSS styles\n├── routes/             # API route handlers\n├── services/           # Business logic\n├── middleware/         # Express middleware\n├── prompts/            # Analysis templates\n│   ├── default/        # Default templates\n│   └── custom/         # User-added templates\n├── utils/              # Helper functions\n├── server.js           # Main application server\n└── package.json        # Dependencies and scripts\n```\n\n### API Endpoints\n\n- `POST /api/analyze` - Analyze a YouTube video\n- `GET /api/prompts` - List available prompt templates\n- `POST /api/prompts` - Add a custom prompt template\n- `POST /api/download/markdown` - Generate a markdown download\n- `GET /api/download/:id/:filename` - Download a generated file\n- `POST /api/notion/connect` - Connect to Notion\n- `GET /api/notion/databases` - List available Notion databases\n- `POST /api/notion/save` - Save analysis to Notion\n- `GET /api/models` - List available AI models\n- `GET /api/health` - Check system health\n\n## Deployment\n\n### Deploying to Heroku\n\n1. Create a Heroku account and install the Heroku CLI\n2. Login to Heroku: `heroku login`\n3. Create a new Heroku app: `heroku create your-app-name`\n4. Add environment variables: `heroku config:set YOUTUBE_API_KEY=your_key`\n5. Deploy the app: `git push heroku main`\n\n### Deploying to Vercel\n\n1. Install Vercel CLI: `npm install -g vercel`\n2. Login to Vercel: `vercel login`\n3. Deploy the app: `vercel`\n4. Set environment variables in the Vercel dashboard\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n## License\n\nThis project is licensed under the MIT License - see the LICENSE file for details.\n```\n2. Create API documentation with endpoint details\n3. Implement unit tests for core services:\n```javascript\n// Example test for YouTube service\nconst { extractVideoId } = require('../services/youtube');\n\ndescribe('YouTube Service', () => {\n  test('extractVideoId should parse standard YouTube URL', () => {\n    const url = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ';\n    expect(extractVideoId(url)).toBe('dQw4w9WgXcQ');\n  });\n  \n  test('extractVideoId should parse shortened URL', () => {\n    const url = 'https://youtu.be/dQw4w9WgXcQ';\n    expect(extractVideoId(url)).toBe('dQw4w9WgXcQ');\n  });\n  \n  test('extractVideoId should parse embed URL', () => {\n    const url = 'https://youtube.com/embed/dQw4w9WgXcQ';\n    expect(extractVideoId(url)).toBe('dQw4w9WgXcQ');\n  });\n  \n  test('extractVideoId should parse shorts URL', () => {\n    const url = 'https://youtube.com/shorts/dQw4w9WgXcQ';\n    expect(extractVideoId(url)).toBe('dQw4w9WgXcQ');\n  });\n  \n  test('extractVideoId should throw error for invalid URL', () => {\n    const url = 'https://example.com/video';\n    expect(() => extractVideoId(url)).toThrow('Invalid YouTube URL format');\n  });\n});\n```\n4. Create deployment scripts and instructions\n5. Add environment variable documentation\n6. Create user guide with screenshots\n7. Implement end-to-end testing",
        "testStrategy": "1. Verify documentation accuracy and completeness\n2. Test installation process on different platforms\n3. Run unit tests for all core services\n4. Validate API documentation against actual endpoints\n5. Test deployment scripts\n6. Verify environment variable documentation\n7. Test user guide with actual usage scenarios",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-03T02:25:28.517Z",
      "updated": "2025-08-03T02:28:05.543Z",
      "description": "Tasks for master context"
    }
  }
}